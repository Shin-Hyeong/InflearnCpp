#include <iostream>
using namespace std;

// 타입 변환
// void* pointer = malloc(1000); -> malloc을 void*로 반환하고
// Player p1 = (Player*)pointer; -> void*을 Player*을 타입 변환을 통해 사용했음.

class Knight
{
public:
    int _hp = 10;
};

class Dog
{
public:
    // 타입 변환 생성자
    Dog(const Knight& knight)
    {
        _age = knight._hp;
    }
public:
    int _age = 1;
};

int main()
{
    //--------------- 타입 변환 유형 (비트열 재구성 여부) --------------

    // [1] 값 타입 변환
    // 특징) 의미를 유지하기 위해서, 원본 객체와 다른 비트열 재구성
    {
        int a = 123456789;      // 2의 보수
        float b = (float)a;     // 부동소수점(지수 + 유효숫자)
        cout << b << endl;      // 1.23457e+008 -> 소수 6번째 자리에서 반올림
                                // 1.23457 : 유효숫자, e+ : 지수 시작점, 008 : 지수 값.
                                // 1.23457 * 10^8 = 123457
        // a의 비트열 : 075bcd15
        // b의 비트열 : 4ceb79a3
        // 같은 값을 넣었지만 값(비트열)이 달라짐
    }

    // [2] 참조 타입 변환
    // 특징) 비트열을 재구성하지 않고, '관점'만 바꾸는 것
    // 거의 쓸일은 없지만, 포인터 타입 변환도 참조 타입 변환과 동일한 룰을 사용함
    {
        int a = 123456789;
        float b =(float&)a;
        cout << b << endl;       // 1.6536e-034
        // a의 비트열 : 075bcd15
        // b의 비트열 : 075bcd15
        // 비트열은 그대로 가지고 있지만 2의 보수로 계산하던것을 부동소수점 계산하도록 바뀜.
    }

    //--------------- 안전도 분류 --------------
    
    // [1] 안전한 변환
    // 특징) 의미가 항상 100% 완전히 일치하는 경우
    // 같은 타입이면서 크기만 더 큰 바구니로 이동
    // 작은 사이즈 -> 큰 사이즈로 이동 OK (업캐스팅)
    // ex) char -> short, short -> int, int -> __int64
    {
        int a = 123456789;
        __int64 b = a;  // 업캐스팅
        cout << b << endl;  // 123456789
    }

    // [2] 불안전한 변화
    // 특징) 의미가 항상 100% 일치한다고 보장하지 못하는 경우
    // 타입이 다르거나
    // 같은 타입이지만 큰 사이즈 -> 작은 사이즈 이동 (다운캐스팅)
    {
        int a = 123456789;
        float b = a;    // 타입이 달라짐.
        short c = a;    // 다운캐스팅
        cout << b << endl;  // 1.23457e+008
        cout << c << endl;  // -13035
    }

    //--------------- 프로그래머 의도에 따라 분류 --------------

    // [1] 암시적 변환
    // 특징) 이미 알려진 타입 변환 규칙에 따라서 컴파일러 '자동'으로 타입 변환 
    {
        int a = 123456789;
        float b = a; // 암시적으로 변환 (float)a 라고 안씀. 경고가 뜰수 있음.
        cout << b << endl; // 1.23457e+008
    }

    // [2] 명시적 변환
    {
        int a = 123456789;
        // (int*)을 붙이지 않으면 컴파일러가 타입이 전혀 맞지 않아 오류를 일으킴
        // 명시적으로 표현함으로써 프로그래머가 위험을 알고 강제적으로 변환을 일으킴
        int* b = (int*)a;
        cout << b << endl; // a의 주소를 가지고 됨.    0x75bcd15
    }

    //--------------- 아무런 연관 관계가 없는 클래스 사이의 변환 --------------

    // [1] 연관없는 클래스 사이의 '값 타입' 변환
    // 특징) 일반적으로 안됨
    // 예외적으로 class 내에서  타입변환 생성자, 타입변환 연산자 생성하면 가능해짐.
    {
        Knight knight;
        Dog dog = (Dog)knight;
    }


    return 0;
}